/**
   Motorola 6845 CRTC Address Generator for Amstrad CPC.

   Set the registers as needed, and let it generate the screen
   addresses.
 */
#include "crtc.h"

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <errno.h>
#include <string.h>

#define VIDEO_ADDR(MA, RA) \
    ((MA & 0x3FF) << 1) | ((RA & 7) << 11) | ((MA & 0x3000) << 2)

void crtc_init(struct crtc_s regs, unsigned short **lines_ptr, int *line_count)
{
    u8 R0;
    u8 R1;
    u8 R6;
    u8 R9;
    u8 R12;
    u8 R13;
    int clock;
    u16 *lines;
    int line_counter;
    int refresh_addr;
    int i;

    line_counter = 0;

    R0 = regs.R0;
    R1 = regs.R1;
    R6 = regs.R6;
    R9 = regs.R9;
    R12 = regs.R12 & 0x3f;
    R13 = regs.R13;

    refresh_addr = (u16) R13 | (((u16) R12 << 8));

    lines = malloc(R6 * (R9 + 1) * 2);
    *lines_ptr = lines;

    clock = 0;

    while (1) {
        u16 MA; /* MA pins on CRTC */
        u16 RA;  /* Raster pins on CRTC */
        int line;

        line = clock / ((R9 + 1) * (R0 + 1));

        MA = refresh_addr + (line * R1 + (clock % (R0 + 1)));
        RA = (clock / (R0 + 1)) % (R9 + 1);

        if (line >= R6) {
            break;
        }

        if (clock % (R0 + 1) == 0) {
            lines[line_counter++] = VIDEO_ADDR(MA, RA);
            /* lines[line_counter++] = MA; */
            /* lines[line_counter++] = RA; */
        }

        clock += 1;
    }

    *line_count = line_counter;
}

#ifdef MAIN

void print_binary(unsigned short val, char *dest, int highlight)
{
    int i;
    int k;

    k = 16 + 2;

    dest[k + 1] = 0;

    for (i = 0; i < 16; i++) {
        if (i != 0 && i % 4 == 0) {
            dest[k--] = ' ';
        }

        if (highlight == -1 || i == highlight) {
            dest[k--] = ((1 << i) & val) ? '1' : '0';
        } else {
            dest[k--] = '#';
        }
    }
}

int main(int argc, char *argv[])
{
    int i;
    int binary_info;
    struct crtc_s regs = { 0x3f, 0x32, 0x23, 7, 0x0c, 24 };

    binary_info = 0;

    if (argc < (1 + 6)) {
        fprintf(stderr, "Usage: %s (R0) (R1) (R6) (R9) (R12) (R13) "
                "[b0 b1 b2 b3] [--binary-info]\n", argv[0]);
        fprintf(stderr, "  where R is the CRTC register values,\n");
        fprintf(stderr, "  where b is the 4K memory bank index (Optional).\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "Example for default CRTC values:\n");
        fprintf(stderr, "  %s 63 40 25 7 48 0\n", argv[0]);
        fprintf(stderr, "\n");
        fprintf(stderr, "Notes:\n");
        fprintf(stderr, "  This utility generates address lines generated by the wiring of\n"
                "Motorla 6845 CRTC chip on Amstrad CPC for every clock cycle in a\n"
                "single frame.\n");

        exit(1);
    }

    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--binary-info") == 0) {
            binary_info = 1;
        }
    }

    for (i = 1; i < 7; i++) {
        u8 *r;

        r = i == 1 ? &regs.R0 :
            i == 2 ? &regs.R1 :
            i == 3 ? &regs.R6 :
            i == 4 ? &regs.R9 :
            i == 5 ? &regs.R12 :
            i == 6 ? &regs.R13 : NULL;

        errno = 0;
        if (strchr(argv[i], 'x') || strchr(argv[i], '&')) {
            sscanf(argv[i], "%x", r);
        } else {
            sscanf(argv[i], "%d", r);
        }
        if (errno) {
            fprintf(stderr, "No digit found at index: %d\n", 1);
            exit(1);
        }
    }

    /* Banks conversion map: default */
    int banks[4] = { 0, 1, 2, 3 };

    if (argc == 7 + 4) {
        for (i = 0; i < 3; i++) {
            int j = i + 7;
            errno = 0;
            if (strchr(argv[j], 'x') || strchr(argv[j], '&')) {
                sscanf(argv[j], "%x", &banks[i]);
            } else {
                sscanf(argv[j], "%d", &banks[i]);
            }
            if (errno) {
                fprintf(stderr, "No digit found at index: %d\n", 1);
                exit(1);
            }
        }
    }

    printf("; R0: %d, R1: %d, R6: %d, R9: %d, R12: %d, R13: %d\n",
           regs.R0, regs.R1, regs.R6, regs.R9, regs.R12, regs.R13);
    printf("; Banks: %d %d %d %d\n", banks[0], banks[1], banks[2], banks[3]);

    unsigned short *lines;
    int line_counter;

    crtc_init(regs, &lines, &line_counter);

    for (i = 0; i < line_counter; i++) {
        u16 cur_line_addr = lines[i];
        int cur_bank_index;
        int bank_offset;
        u16 address;

        if (cur_line_addr >= 0 && cur_line_addr < 0x4000) {
            cur_bank_index = 0;
        } else if (cur_line_addr >= 0x4000 && cur_line_addr < 0x8000) {
            cur_bank_index = 1;
        } else if (cur_line_addr >= 0x8000 && cur_line_addr < 0xc000) {
            cur_bank_index = 2;
        } else if (cur_line_addr >= 0xc000 && cur_line_addr <= 0xffff) {
            cur_bank_index = 3;
        } else {
            assert(0);
        }

        bank_offset = (banks[cur_bank_index] - cur_bank_index) * 0x4000;
        address = cur_line_addr + bank_offset;

        if (binary_info) {
            char buf[16];

            if (i % (regs.R9 + 1) == 0) {
                if (i != 0) {
                    printf("\n");
                }
            }

            print_binary(address, buf, -1);

            printf("0x%.4x (%s)", address, buf);

            if ((i + 1) % (regs.R9 + 1) != 0) {
                printf(", ");
            }
        } else {
            if (i % (regs.R9 + 1) == 0) {
                if (i != 0) {
                    printf("\n");
                }

                printf("    dw ");
            }

            printf("0x%.4x", address);

            if ((i + 1) % (regs.R9 + 1) != 0) {
                printf(", ");
            }
        }
    }

    putchar('\n');

    free(lines);
    return 0;
}
#endif
